<html>
    <head>
        <meta charset ="utf-8">
        <body>

$ tmux -><br>
터미널 멀티플럭서의 줄임말로 터미널에서 개발을 진행할 때 유용한 기능을 제공하는 프로그래이다. 어떠한 터미널에서 session을 싱행 하면 그 세선 안에 작업창을 여러 개 나누어 병렬적으로 일을 수행할 수있다. 이렇게 터미널을 나누어 작업 하는 것이 tmux의 핵심 키워드라거 할 수 있다.<br>
예로 서버에 시간이 오래 걸리는 작업을 백그라운드로 켜놓고 터미널을 종료 후 다른 작업을 해야할 때 자주 쓰인다.<br>
<p></p>
$ ufw -><br>
utf란 리눅스 환경에서 작동하는 사용하기 쉽게 설계된 넷필더 방화벽을 관리하는 프로그램이다.<br>
여기서 방화벽이란 미리 정의된 보안 규칙에 기반한, 들어오고 나가는 네트워크 트래픽을모니터링하고 제어하는 네트워크 보안 시스템이다.<br>
sudo ufw enable // 방화벽을 황성화 하는 명렁어<br>
sudo ufw disable  // 방화벽을 비활성화 하는 명령어’<br>
sudo ufw allow “포트 넘버” // 해당 포드 넘버를 모든 사용자가 접속할 수 있도로 허용함<br>
sudo ufw deny “포트넘버”  // 해당 포트 넘버를 모든 사용자가 접속 할 수 없도록 함<br>
sudo ufw allow from “IP” // 해당 아이피에 대해 모든 포트 접속 허용<br>
등등이 있다.<br>
<p></p>
$ iptables -><br>
iptables는 리눅스상에서 방화벽을 설정하는 도구로서 커널 2.4 이전 버전에서 사용되던 ipchains를 대신하는 방화벽 도구이다. <br>
iptables는 커널상에서의 netfilter 패킷필터링 기능을 사용자 공간에서 제어하는 수준으로 사용할 수 있다.<br>
패킷필터링이란 지나가는 패킷의 해더를 보고 그 전체 패킷의 운명을 결정하는 것을 말한다. 일반적으로 패킷은 해더와 데이터를 가진다. <br>
특정 조건을 가지고 있는 패킷에 대해 허용과 차단등을 지정할 수 있으며, 특정 조건등을 통해 다양한 방식의 패킷 필터링과 처리 방식을 지원한다.<br>
<p></p>
$ SVN -><br>
sub Version 형상관리 도구중 하나로서 파일 서버 라고 보면된다.<br>
하나의 파일 서버에 여러 사람이 작업한 프로젝트의 소스를 통합(코밋, 푸시,)밀 관리(브랜치)등을 하면 저장하기 위해 사용한다.<br>
SVN의 소스코드는 TRUNK 라는 곳에 위치한다. 각자 로컬 pc에 소스코드를 내려 받고 소스를 업로드 하여 다시 SVN 서버에 업데이트 하는 방식이다.<br>
 SVN은 중앙 집중식 코드 관리 방식입니다. 위 그림처럼 하나의 SVN Repository에 접근 가능한 모든 PC가 달라붙어서 소스 코드를 관리합니다<br>
개인이 버전 관리를 못한다. 무조건 파일 서버에 Commit 하기 때문에, 다른 사람들의 Log History까지 쭈욱 살펴가면서 자기의 Commit을 찾거나 소스를 찾거나 해야합니다. <br>
Git 또한 SVN과 같이 형상 관리 도구입니다. Git 서버에 소스코드를 올리거나 브랜치를 사용하며 관리한다. SVN과 차이점은 <br>
중앙 집중식 코드 관리 방식의 SVN과는 다르게 Git은 분산 소스코드 관리 방식 이다 그렇기에 빠르고 안전하다.<br>
Git은 각각의 PC에 Local Repository가 존재합니다. 그래서 Git Repository(Server Repository) 에 매 Commit마다 접근해서 push하는게 아니라 Local Repository에 Commit하며 쌓아두고 한번에 push해도 됩다.<br>
단점은 git을 사용하기 위해 git 수행 방법, branch, merge, pull, request, rebase 등등 여러 명령어를 학습해야한다.<br>
<p></p>
$ branch -><br>
브렌치란 소프트웨어 개발시 개발자들에게 동일한 소스코드 위에서 산규 개발, 버그 수정 등의 업무를 협업 할때, 여려 개발자들이 동시에 다양한 작업을 할 수 있도록 만들어주는 기능이다.<br>
브렌치를 통해 하나의 프로젝트를 여러 갈래로 나누어 관리할으며 각각의 브렌치는 독립적으로 관리 되며 원래버전과 다르게 코드를 작성할 수 있고 또 나중에 합칠 수 도 있다.<br>
git branch “이름” // 해당 이름의 브렌치 생성<br>
git branch //현재 내가 위치한 브렌치 확인 명령어<br>
git branch -r // 원격 저장소의 브랜치 확인<br>
git branch -v // 브랜치의 마지막 커밋 메시지 확인<br>
git checkout “브렌치 명” 해당 브렌치로 이동할 수 있다.<br>
git restore // 작업 중인 파일(변경 내역이 있는 파일을 복원한다.<br>
<p></p>
$ stash -> 	<br>
stash 란 git 폴더 내부에서 작업을 햇을 때 작업물은 unstaged Area나 staged area에 저장된다. 이때 만약 작업물을 커밋 하지 않고 다른 브랜치로 변경할 경우 변경 사항이 같이 따라가게 된다.<br>
따라서 이러한 작업물들을 저장할 임시 공간이 푤요한데, 그 공간으로 작업물을 보내는 명령어가 git stash 이다.<br>
git stash “ 이름 “//현재 작업을 일시적으로 저장 하는 명령어<br>
git stash list // 일시적으로 저장해 둔 작업 목록을 확인할 때 사용하는 명령어<br>
git stash pop // 일시적으로 저장해 둔 작업을 되돌릴 때 사용하는 명령어<br>
git stash drop // 일시적으로 저장한 작업을 삭제하는 명령어<br>
<p></p>
$ merge -><br>
Git으로 소스 코드의 버전 관리를 할 때, 보통 main 브랜치는 최종 버전의 소스 코드(실 서비스에 배포된 소스 코드)를 관리하게 됩니다. 그리고, main 브랜치가 아닌 브랜치를 생성하고 새로운 기능을 개발한 후, 개발이 완료되면, main 브랜치에 병합(Merge)하게 됩니다.<br>
git merge “브렌치 명” // 현재 브랜치에 해당 브렌치를 병합한다.<br>
<p></p>
$ conflict -><br>
현재 브랜치에서 다른 브랜치를 머지할 때 아무 문제없이 잘 끝날 때도 있지만 어떤 경우는 출동 하기도 한다.<br>
두개의 브랜치를 동일한 파일에 병합할 때 상반된 내용이 있을때, git에서 두 가지 중에 어떤 내용을 merge 결과로 해야할 지 모르기 때문에 사용자가 결정해줘야 한다.<br>
<p></p>
$ Gradle과 Maven 의 차이점 -><br>
maven 같은 경우 스프링 프로젝트에서 pom.xml 이라는 이름을 사용하고  gradle는 스프링 부트 안드로이드 에서 사용한다.<br>
Maven이란?<br>
프로젝트를 진행하게 되면 단순히 자신이 사용한 코드만으로 개발하는 것 이 아니라 많은 라이브러리를 통해 개발을 하게 된다. 이 때 사용하는 라이브러리의 수가 수 십개 넘어버리면 라이브러기 관리가 힘들어진다. maven을 사용하면 이러한 문제를 해결할 수 있다.<br>
Maven은 내가 사용할 라이브러리 뿐만 아니라 해당 라이브러리가 작동하는데 필요한 다른 라이브러리들까지 관리하여 네트워크를 통해 자동으로 다운 받아준다.<br>
gradle 이란?<br>
gradle이란 기본적으로 빌드 배포 도구이다. 안드로이드 앱을 만들 때 필요한 공식 빌드시스템이며 java c c++ 파이썬 등을 지원한다.<br>
빌드툴인 ant builder와 그루비 스크팁트를 기반으로 구축되어 기본 ant의 역할과 배포 스크립트의 기능을 모두 이용 가능 하다.<br>
기본 메이븐의 경우 XML로 라이브러리를 정의하고 활용하도록 되어 있으나, Gradle의 경우 별도의 빌드스크립트를 통하여 사용할 어플리케이션 버전, 라이브러리등의 항목을 설정 할 수 있다.<br>
스크립트 언어로 구성되어 있기때문에, XML과 달리 변수선언, if, else, for등의 로직이 구현가능하여 간결하게 구성 가능함<br>
<p></p>
$ JIRA -><br>
JIRA는 엔지니어가 작업을 하고 관리하는데 사용하는 소프트웨어 개발 도구다. 애자일 및 워터플 프로젝트 관리에 모두 사용가능 하며 버그, 기타 기능 및 작업 항목을 추적하고 관리할 수 있다.  <br>
JIRA의 기능에는 워크플로 사용자 정의, 강력한 검색 기능, 구성 가능한 문제 필드, 유연한 보고 및 인기 있는 개발 도구와의 통합이 포함한다.<br>
모든 규모의 조직은 JIRA를 사용하여 모든 유형의 프로젝트를 관리된다.<br>
jlra core  // 팀에서 제품을 계획, 추적 및 출시하는 데 사용하는 프로젝트 관리 도구입니다. 사용자에게 프로젝트 진행 상황에 대한 실시간 가시성을 제공한다.<br>
jira software //  소프트웨어 개발자는 프로젝트 내에서 문제를 추적하기 위해 기본 JIRA 소프트웨어를 사용합니다. 버그, 기능 및 작업을 추적하고 워크플로 및 프로세스 다이어그램을 생성함<br>
지라 서비스 데스크 // JIRA 서비스 데스크를 통해 기업은 모든 요청을 한 곳에서 볼 수 있으며 고객 서비스를 보다 효과적으로 관리하는 데 도움이 되는 추가 기능을 제공함<br>
<p></p>
$ JUnit -><br>
JUnuit는 단위 테스트 도구이다. 외부 테스트 프로그램을 작성하여 디버깅 하지 않아도 된다. 프로그램 테스트 시 걸릴 시간을 관리할 수 있고 오픈소스 이며 이클립스에 기본 탑제 되어 있음.  JUnut는 보이지 않고 숨은 단위 테스트를 끌어내어 정형화 시켜 단위 테스트를 쉽게 해주는 프로그램이다.<br>
<p></p>
$ Jenkins -><br>
젠킨스란 모든 언어의 조합과 소스 코드 레포지토레 애한 지속적인 통합과 지속적 배포 환경을 구측하기 우히나 도구다.<br>
빌드, 테스트, 배포, 프로세스를 자동화하여 소프트웨어 품질과 개발 생산성을 높일 수 있다.<br>
프로젝트 기간 중에 개발자들은 순수한 개발 작업 이외의 DB 설정, 환경 설정, Deploy 작업과 같은 단순 작업에 시간과 노력을 들이는데, 이러한 작업들을 젠킨스를 사용함으로 젠킨스에서 지원하는 웹 인터페이스를 통해 쉽게 수행할 수 있게 된다. 젠킨스는 온갖 종류의 개발 작업을 지원하기 위한 약 1,400가지의 플러그인을 가지고 있는 오픈소스 자동화 서버다. 위 플러그인은 플랫폼, UI, 관리, 소스코드 관리, 빌드 관리의 5가지의 영역을 포괄하고 있다.<br>
<p></p>
gitLab -><br>
GitLab은 완전히 웹 기반인 Git 리포지토리로 무료 개방형 및 비공개 리포지토리, 문제 추적 기능 및 Wiki를 모두 제공한다.<br>
전문가가 프로젝트 계획 및 소스 코드 관리, 모니터링 및 보안을 포함하여 프로젝트의 모든 작업을 수행할 수 있도록 하는 완전한 DevOps 플랫폼입니다.<br>
<p></p>
$ Kubernetes -><br>
Kubernetes는 컨테이너화된 애플리케이션을 자동으로 배포, 스케일링 및 관리하기 위한 오픈소스 플랫폼이다. 간단히 말해, 애플리케이션을 관리하기 쉽게 만들어 준다.<br>
쿠버네티스는 어플리케이션을 쉽게 사용 배포 할 수 있다. 쿠버네티스는 어플리케션을 자동으로 스케일링하고 장애 복구를 처리하는 등의 작업을 처리 하여 시스템 안정성을 높인다. 클라우드 환경을 제공해 클라우드 어플리케이션 실행도 가능ㄴ하다<br>
<p></p>
$ ELB -><br>
로스 벨런서 Load balancer는 부하를 적절하게 분배해주는 장치다. AWS에서 ELB(ㄷElastic Load Balancer 라는 이름으로 로드 밸런서를 제공한다.  이 시스템은 자동으로 로드 밸런싱을 제공하며 시스템이 서버가 죽지 안도록 알아서 관리해준다.<br>
AWS ELB는 엔드포인트 역할을 제공한다. 로드벨런서는 이런 부하를 분산 하는 것 뿐만 아니라 스케일 아웃에 대한 엔드포인트를 제공하기도 한다<br>
또한 오토 스케일링 기능도 제공한다<br>
오토스케일리은 트래픽이 몰릴 때 컴퓨터 수를 자동으로 늘림으로 서버 사이즈를 조절해 서버가 원활이 유지될 수 있도록 해준다. <br>
또한트 래픽이 적을경우 인스턴스를 감소시켜 비용 낭비를 막아주는 서비스이며, AWS ELB는 트래픽을 오토 스케일링을 통해 늘린 수만개의 인스턴스들에게 부하(트래픽)를 분산하는 서비스 이다.<br>
<p></p>
$ ELK스택 (Elasticsearch, Logstash, Kibana) -><br>
Elasticsearch<br>
Elasticsearch란 아파치 루씬  기반의 java오픈소스 분산 검색 엔진이다.<br>
Elasticsearch 를 통해 루씬 라이브러리를 단독으로 사용할 수 있으며 방대한 양의 데이터를 신속하게 실사간에 가깝게 저장, 검색, 분석이 가능하다.<br>
클러스터란 Elasticsearch 에서 가장 큰 시스템 단위를 의미하며 최소 하나 이상의 노드로 이루어진 노드의 집합이다. 서로 다른 클러스는 데이터 접근 교환을 할 수 없는 독립적인 시스템으로 유지 되며, 여러 대의 서버가 하나의 클러스터를 구성할 수 있고 한 서버에 여러 개의 클러스터가 존재 할 수 있다.<br>
노드 <br>
Elasticsearch를 구성하는 하나의 단위 프로세스를 말한다.<br>
인덱스 <br>
Elasticsearch 에서 인덱스는 RDBMS에서 database 와 대응하느 개념이다.<br>
또한 shard와 replica는 Elasticsearch에만 존재하는 개념이 아니라 분산 데이터베이스 시스템에도 존재하는 개념이다.<br>
<p></p>
Logstash<br>
Logstash란 플러스인 기반의 오픈소스 데이터 파이프라인 도구다.<br>
데이터 전처리 과정을 별도 어플리케이션 작성 없이 비교적 간단한 설정만으로 수행할 수 있다.<br>
파이프라인<br>
Logstash에서 파이프라인이란 데이터를 입력받아 실시간으로 변경하고 이를 다른 시스템에 전달하는 역할을 하는 로그스태시의 핵심 기능이다. 입력, 필터, 출력으로 이루어져있다.<br>

Kibana<br>
Kibana는 데이터의 형태를 만들고 elastic stack을 탐색할 수 있게 하는 시각화 및 관리 서비스이다.<br>
Kibana로 검색, 관찰, 데이터보호, 데이터분석,  모니터링등등을 할 수 있다.<br>
        </body>
    </head>
</html> 
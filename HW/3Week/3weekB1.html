<html>
    <head>
        <meta charset ="utf-8">
        <body>
            gdb -><br>
            $gdb란 GNU porject의 디버거로 실행된는 상황 또는 충돌이 발생한 프로그램에서 일어난 일을 볼 수 있다.<br>
            <p></p>
            C언어 헤더 파일 -><br>
            c언어에서 함수는 사용되기 전에 먼저 해당 함수의 원형이 선언되어야 한다. 이러한 표준 함수의 원형 및 함수와 관련된 정보를 가지고 있는 파일을 표준 해더 파일 이라고한다.<br>
            표준 헤더파일 // 표준 함수의 원형 및 표준 함수와 관련된 다양한 정보를 가지고 있다.<br>
            표준 헤더 파일에 저장되는 정보는 표준 함수의 원형, 표준 함수의 매크로 상수, 표준 함수의 사용자 정의 타입(구조체, 공용체) 정의 ,매크로 함수의 정의 가 있다.<br>
            산업용 프로그램에서 볼륨이 큰 프로그램에 함수가 많기에, 소스파일을 용도에 맞게 쪼개어 효율적으로 관리할 수 있다.<br>
            <p></p>
            fopen과 freopen -><br>
            $ fopen은 파일을 열어주는 함수이다.<br>
            파일을 열게 되면 파일 스트림형 구조체 “FLIE”을 리턴 받게 되는데 이는 자체적인 입출력 버퍼를 지닌다는 특징이 있습니다. 이 버퍼는 시스템 버퍼가 아닌 라이브러리 레벨의 벞퍼다.<br>
            & freopen은 파일을 닫고 다시 열엉주는 함수이다.<br>
            주로 stdin, stdout, stderr을 바꾸기 위해 쓰거나 접근 모드를 변경하기 위해 사용한다.<br>
            & fdopen 파일디스크럽터로 파일을 열어주는 함수이다.<br>
            open()    dup()  에 주로 쓰이는 함수다.<br>
            fliepath : 열고자 하는 파일의 경로<br>
            mode : 파일의 접근 모드<br>
            r, eb // 파일을 읽기 전용으로 오픈, 쓰기 시 에러 발생, 지정된 파일이 존제하지 않으면 NULL을 리턴<br>
            w, wb // 파일을 쓰기 전용으로 오픈, 지정한 파일이 존재하지 않으면 파일을 생성하고, 이미 있더라고 원래 데이터는 초기화<br>
            a .ab // 파일을 이어쓰기 모드로 오픈, 지정한 파ㅇ일이 존재하지 않으면 파일을 생성하고, 이미 있으면 원래 데이터를 유지한 채로 새로운 데이터 파일을 마지막에 추가  . 이 모드로 열염ㄴ 파일 중간의 내용을 덮어쓸 수 없다.<br>
            r+ rb+ r +b // 읽기 + 쓰기 모드로 오픈, 지정된 파일이 존재하지 않으면 fopen() 호출 후 리턴,<br>
            w+, wb+, w+ b 읽기 + 쓰기 모드로 오픈, 지정된 파일이 존재하지 않으면 파일 생성, 이미 존재한다면 원래 데이터는 초기화<br>
            a + , ab+ a+b // 읽기 + 쓰기 모드 이지만 이어쓰기 모드로 오픈 a모드랑 다를게 없음<br>
            <p></p>
            C++의 cout-><br>
            $ C++ cout은 c언어의 printf와 달리 출력할 것이 문자인지 정수인지 소수인지 자동으로 알아차리고 출력한다. 위와 같은 것이 가능한 이유는 개개체 지향 기능을 가지고 있기 때문이다. 연산자의 오버로딩의 한 예이다.<br>
            특징은 cout은 문자열, 수, 문자 등 다양한 데이터 형을 서식 문자 없이 자동으로 출력해 준다.
            cout 에서 << 표시는 왼쪽 시프트 연산자라고 불리지 않고 삽입 연산자라고 부른다.<br>
            <p></p>
            cin과 scanf -><br>
            $ cin은 ascii 10 개행을 무시하지만 scanf는 ascii 10 개행을 무시하지 않고 입력 받는다.<br>
            알고리즘 문제 해결에 있어서 scanf와 printf가 입력, 출력 속도가 훨씬 빠르다.<br>
            whitespace의 저장에도 차이가 있는데 cin은 문자 받을 때 무사하고 저장, / scanf는 저장.<br>
            <p></p>
            포인터(*)와 참조(&)의 차이 -><br>
            $ 포인터는 NULL을 허용 하지만 참조자는 NULL을 허용하지 않는다.<br>
            포인터를 할당 할 때 참조 대상에 대해 & 연산을 통해 주소값을 할당한다. 반면 참조자에서는 대상 그대로를 할당함.<br>
            그러므로 레퍼런스 변수에서는 NULL을 할당할 수 없다.<br>
            <p></p>
            콜백 함수와 콜백 지옥 -><br>
            $콜백 함수란 함수의 매개 변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수 callback function 이라고 한다. 콜백 함수는 고차 함수에 의해 호출되며, 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.<br>
            콜백 함수가 필요한 이유는 자바스크립트는 비동기 프로그램을 위한 즉, 이벤트르르 처리하기 위해 만들어진 언어이기 때문에 한 명령어에 대한 응답을 기다리는 것 보다는 다음 명령어를 먼저 수행하기  위해 콜백 함수를 사용한다. 자바스크립트 c8엔진은 싱글 쓰레드 이기 때문에 여러가지 명령어를 동시에 수행 할 수 없다.<br>
            따라서 한 명령어의 응답 시간이 오래 걸리면 속도가 느려진다.<br>
            콜백 지옥<br>
            자바스크립트에서 비동기 작업을 처리할 때 콜백함수를 사용하는데 콜백 함수를 중첩해서 사용하며면 코드의 가독성이 나빠지고 유지보수가 어려워지는 상태가 발생할 수 있다.<br>
            이러한 문제를 얼켜 콜백 지옥 callback hell 이라고 한다.<br>
            <p></p>
            C++ auto 타입과 제네릭 타입 -><br>
            auto타입은 “타입 추론” 데이터 타입 추론, 자동 데이터 타입 추론, 등등 으로 불린다 요약 하자면 auto는 초기화 값에 따라 알아서 데이터 타입을 정해준는 키워드 이다.<br>
            auto를 사용하면 아래 예제 처럼 변수를 선언할 수 있다.<br>
            auto a1 = 10;              // int 타입 <br>
            auto a2 = 10.0f;           // float 타입 <br>
            auto a3 = "c";             // char 타입 <br>
            auto a4 = "BlockDMask";    // <br>
            string 타입 auto a5 = {10, 20, 30};       //int 배열 타입<br>
            auto를 그냥 사용할 수 있지만 한정자와 함께 사용함으로써 효율을 더 높일 수 있습니다.<br>
            <p></p>
            void 포인터와 malloc -><br>
            $ c에서 동적메모리 할당을 위해 malloc 또는 calloc를 사용한다.<br>
            void point 란<br>
            void point는 타입이 없는 포인터이다. 포인터는 주소값을 저장하는데 보통 타입이 있어야 한다. 예를 들어 int형 포인터 변수에 double 변수의 주소값을 저장하거나, 한다면 큰 메모리 침범 및 오류가 발생할 수 있다. 따라더 정확한 탕비의 포인터 변수에 해당하는 타입 변수의 주소값을 넣어야 한다.<br>
            동적 메모리 할당<br>
            c에서 사용하는 동적메모리 할당은 malloc, calloc 이다.<br>
            void *malloc(sizeof( … ))<br>
            할당하고자 하는 메모리가 있는데, malloc을 이용해서 원하는 만큼의 크기를 전달해준다. 그러면 malloc함수는 현재 메모리를 검사하여 원하는 만큼의 빈공간이 있는 곳을 찾아낸다.<br>
            이후에 그만큼의 메모리를 다른데서 사용하지 못하도록 할당한 후에 그 메모리의 첫번째 주소값을 돌려준다. <br>
            여기서 리턴 값이 void 형태다.<br>
            이것은 malloc함수는 메모리를 할당하고 그 첫번째의 주소값을 돌려줄뿐, 그 주소에 접근해서 어떻게 데이터를 저장하고 읽어오고 하는 등의 사용방법은 개발자의 몫이다.<br>
            만약 이게 정해져있다면, 리턴타입이 여러개여야 할 것이다. char, int, double, 각종 구조체타입등 수많은 타입들을 다 만들어둘수가 없다. 몇몇 primitive타입들은 만들어둘수도 있으나, 사용자가 정의하는 구조체타입은 무한하기때문에 정의해두는게 불가능함<br>
            <p></p>
            gcc의 컴파일 과정 -><br>
            $ GCC(GNU Compiler Collection)는 GNU 컴파일러 모음으로 GNU 프로젝트의 일환인 컴파일러이다. 원래는 GNU C Compiler의 약자였지만 C++, JAVA 등 여러 언어를 컴파일 할 수 있게 되면서 현재의 이름으로 바뀌게 되었다. GCC는 컴파일러 모음이기 때문에 단순히 컴파일 과정뿐만 아니라 전처리 과정, 어셈블 과정, 링킹 과정과 같이 실행 파일(binary file)을 만드는데 필요한 작업을 모두 수행한다.<br>
            gcc의 동작 과정<br>
            첫번 째 전처리 과정<br>
            전처리기는 #include 구문을 만나면 해당되는 헤더 파일을 찾아 그 파일의 내용을 삽입한다. 헤더 파일 삽입이 끝난 후 매크로 치환 작업이 시작된다. #define 된 부분은 심볼 테이블에 저장되고 심볼 테이블에 들어있는 문자열과 같은 문자열을 만나면 치환한다. 그 외 다른 전처리기 매크로들도 함께 처리된다.<br>
            두번째 컴파일 과정<br>
            Front-end 부분에서는 소스 코드가 올바르게 작성되었는지 확인하는 과정을 거친다. 그 후 소스 코드를 트리 형태로 표현한 자료 구조인 GIMPLE 트리를 생성한다.<br>
            Middle-end 부분에서는 GIMPLE 트리를 SSA(Static Single Assignment) 형태로 변환한 후 아키텍처 비종속적인 최적화를 수행한다. 그 후 고급 언어와 어셈블리 언어의 중간 형태인 RTL(Register Transfer Language)을 생성한다.<br>
            <p></p>
            새번째 어셈블 과정<br>
            어셈블러에 의해 생성되는 목적 코드인 .o 파일은 어셈블된 프로그램의 명렁어와 데이터가 들어있는 ELF 바이너리 포맷 구조를 갖는다.<br>
            as는 목적 코드 파일의 최상단에 ELF 헤더를 붙인다. ELF 헤더에 대한 자세한 정보들을 보려면 readelf를 통해서 볼 수 있다. ELF 헤더 다음에는 명령어를 붙인다.<br>
            그 후 데이터(전역변수 및 내부에서 사용된 문자열)가 들어가게 된다. 이 후 컴파일한 GCC 컴파일러의 버전 문자열이 들어간다. 그리고 나머지 기타 섹션인 심볼 테이블(symbol table)과 재배치 테이블(relocation table) 섹션이 들어간다.<br>
            <p></p>
            마지막 링킹 과정<br>
            소스 코드에는 사용되지만 직접 정의하지 않은함수를 불러오는 과정이다. <br>
            <p></p>
            nasm과 AT&T -><br>
            $ nasm 어셈블리어 <br>
            80x86 platform 용으로 개발된 어셈블러어다  open-source 개발 되었다.<br>
            그렇기에 MASM과 비슷한 점이 많고, 사람들의 비교 대상도 되곤 합다. NASM의 장점은 현재는 Cross-Platform 을 지원한다는 것과 Macro(단, x86 platform에서) 를 제공한다는 것입니다. 그렇기에 일반적으로 Kernel 과 같이 O/S를 개발할 경우에 많이 사용되는 Assembler 입니다.<br>
            AT&T 문법은 오퍼랜드으위 위치가 인텔 문법(nasm)문법과 정 반대로 사용된다.<br>
            인텔 문법의 경우 목적지 오퍼랜드가먼저 오고 원본 오퍼랜드가 나중에 오지만 AT&T문법은 반대로 되어 있다.<br>
            <p></p>
            빅 엔디안과 리틀 엔디안 -><br>
            $ 컴퓨터는 데이터를 메모리에 저장할 때 byte단위로 나눠서 저장한다. 따라서 연소고디는 비트를 순서대로 저장해야 하는데 이것을 바이트 저장순서 byye order라고 한다. 이때 바이트가 저장된 수넛에 따라 빅 엔디안, 리틀 엔디안 두 가지 방식으로 나눌 수 잇다.<br>
            빅 엔디안(big endian)<br>
            빅 엔디안 방식은 낮은 주소에 데이터의 높은 바이트 (MSB : Most Significant Byte) 부터 저장하느 방식.<br>
            이 방식은 평소 사랑이 사용하는 선형 방식과 같아 메모리 저장 순서 그대로 읽을 수 있다.<br>
            리틀 엔디안(Little endian)<br>
            리틀 엔디안 방식은 낮은 주소에 데이터의 낮은 바이트(LSB : Least Significant Byte)를 저장하는 방식이다. 이 방식은 평소 사람이 숫자를 사용하는 선형 방식과 반대로 거꾸로 읽어야 한다.<br>
            <p></p>
            빅 엔디안과 리틀 엔디안 중 어느 한쪽이 다른 쪽과 비교해 압도적으로 좋거나 나쁘지는 않다고 알려져 있다.<br>
            두 방법은 서로 다른 아키텍처에서 공존한다.<br>
            그러나 x86 아키텍처가 리틀 엔디안을 쓰기 때문에 오늘날 x86 아키텍처를 사용하는 대부분의 데스크톱 컴퓨터는 리틀 엔디언 방식을 사용한다.<br>
            반면, 네트워크에서는 주소를 주로 빅 엔디언으로 쓰는데, 역사적으로 라우팅이 전화를 거는 식으로 접두 부호로 이루어졌기 때문이다.<br>
            빅 엔디안은 소프트웨어의 디버그를 편하게 해주는 경향이 있다. 사람이 숫자를 읽고 쓰는 방법과 같기 때문에 디버깅 과정에서 메모리의 값을 보기 편하기 때문이다.<br>
            가산기(Adder)가 덧셈을 하는 과정을 생각하면 가장 작은 자릿수부터 큰 자릿수로 진행된다. <br>
            따라서 첫 번째 바이트가 LSB인 리틀 엔디안에서는 가산기 설계가 조금 더 단순해진다. 하지만 오늘날의 프로세서는 여러 개의 바이트를 동시에 읽어 들여 동시에 덧셈을 수행하는 구조를 갖기 때문에 두 엔디안 사이에 사실상 차이가 없다.<br>
            숫자의 대소 관계를 비교할 때는 빅 엔디안이 조금 더 빠를 수 있다. 숫자의 비교는 가장 큰 자릿수부터 비교하기 때문에, 첫 번째 바이트가 MSB인 빅 엔디안에 대소 관계 비교는 조금 더 빠를 수 있다.<br>
            
            
            </body>
    </head>
</html> 
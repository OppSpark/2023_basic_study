<html>
    <head>
        <meta charset ="utf-8">
        <body>
            파일 리버싱 -><br>
            $ 리버싱 분석 방법은 크게 2가지로 나뉜다. 정적 분석과 동적 분석이 있다.<br>
            정적 분석 -<br>
            파일의 겉 모습을 관찰하여 분석하는 방법이다. 정적 분석 단계에서는 파일을 실행하지 않는다.<br>
            파일의 종류 파일의 종류(EXE, DLL, DOC, ZIP 등), 크기, 헤더(PE) 정보, Import/Export API, 내부 문자열, 실행 압축 여부, 등록정보, 디버깅 정보, 디지털 인증서 등의 다양한 내용을 확인하는 것입니다.<br>
            또한 디스 어셈블러를 이용해 내부 코드와 그 구조를 확인 하는 것도 정적 분석 방법중 하나이다.<br>
            <p></p>
            동적 분석-<br>
            파일을 직접 실행시켜 그 행위를 분석하고, 디버깅을 통해 코드의 흐름과 메모리 상태 등을 자세히 살펴보는 방법이다.<br>
            파일 레지스트리, 네트워크 등을 관찰하여 프로글매의 행위를 분석한다. 또한 디버거를 이용해 프로그램 내부 구조와 동작 원리를 분석할 수 있다.<br>
            <p></p>
            리버싱에서 취급하는 대상은 보통 실행 파일인 경우가 많다. 소스코드 없이 실행파일의 바이너리 자체를 분석한다.<br>
            <p></p>
            예를 들어 C++ 소드코드에서 빌드 과정을 보자면<br>
            첫번째<br>
            개발도구 (Visual C++)에서 소스코드(helloworld.cpp)를 빌드하면 helloworld.exe 실행 파일이 생성됩니다.<br>
            두번째<br>
            생성된 실행 파일은 컴퓨터가 이해할 수 있는 2진수(Binary) 형식으로 변환 된다. 그러나 아무리 리버싱 전문가라도 0과 1로만 구성되어 있는 binary 파일을 직접 보고 의미를 해석하는 것은 불가능 하다.<br>
            따라서 HexEditor를 이용하여 2진수를 16진수 형식으로 변환 시켜 , 자릿수가 줄어들면서 훨씬 보기에 수월하기 때문입니다.<br>
            세번째<br>
            사람이 이해하기 쉬운 어셈블리 코드 형태로 보기 위해 helloworld.exe 실행파일을 디버거를 이용해 열어보면 디스 어셈블과정을 거쳐서 어셈블리 코드로 변환시킨다. <br>
            <p></p>
            함수 호출 방식(cdecl, stdcall, fastcall)-><br>
            $ 함수 호출 규약(Calling Convention)이란 함수를 호출하는 방식에 대한 약속이다.<br>
            <p></p>
            cdecl<br>
            cdecl은 C 및 C++ 프로그램에 대한 기본 호출 규약이다. 스택이 호출자에 의해 지워지기 때문에, 가변 인자를 가지는 함수를 정의할 수 있다.<br>
            cdecl 지정자는 변수 또는 함수 이름의 앞에 지정해야 합니다.<br>
            기본적으로 cdecl 함수 호출 규약을 따르기 때문에, 컴파일러가 vectorcall, fastcall 등의 다른 호출 규약을 디폴트로 지정하였을 때만 해당 지정자를 사용한다.<br>
            ARM 및 x64 프로세서에서, decl 지정자는 허용되지만 일반적으로 컴파일러에 의해 무시해도 됨<br>
            ARM 및 x64의 컨벤션에 의해, 인자는 가능하다면 레지스터로 전달되고, 후속(subsequent) 인자들은 스택에 전달된다.<br>
            x64 코드에서는, 기본적으로 x64 함수 호출 규약을 따르므로, cdecl 호출 규약을 사용하기 위해서 /Gv 컴파일러 옵션을 통해 재정의하여야 합니다.<br>
            또한, 비정적(non static) 클래스 함수의 경우, 함수의 정의가 클래스 블록 외부에서 정의된 경우, 선언시에만 호출 규약 지정자를 지정하고 함수를 정의하는 곳에서 별도로 함수 호출 규약을 지정할 필요 없음<br>
            <p></p>
            stdcall<br>
            stdcall은 Win32 API 함수를 호출하는 데에 사용되는 함수 호출 규약입니다. 피호출자가 스택을 정리합니다. 이 함수 호출 규약을 사용하는 함수들은 함수 원형(prototype)을 필요로 합니다<br>
            ARM 및 x64 프로세서에서, stdcall은 허용되지만 컴파일러에 의해 무시됩니다; ARM 및 x64의 컨벤션에 의해, 인자는 가능하다면 레지스터로 전달되고, 후속 인자들은 스택에 전달됩니다.<br>
            또한, 비정적 클래스 함수의 경우, 함수의 정의가 클래스 블록 외부에서 정의된 경우, 선언시에만 호출 규약 지정자를 지정하고 함수를 정의하는 곳에서 별도로 함수 호출 규약을 지정할 필요가 없다<br>
            <p></p>
            fastcall<br>
            fastcall은 가능하다면 레지스터로 전달하는 함수 인자들을 지정합니다. 이 함수 호출 규약은 오직 x86 아키텍처에서만 적용할 수 있습니다. fastcall 함수 호출 규약의 구현은 다음과 같다<br>
            <p></p>
            인자 전달 순서 -> 왼쪽에서 오른쪽으로 진행하는 인자 리스트에서 별견된 첫 두개의 dword or 그보다 더 작은 인수가 ECX, EDX 레지서를 통과 -> 다른 모든 인수는 오른쪽에서 왼쪽으로 스텍에 전달된다.<br>
            스텍 유지 관리 책임 -> 피호출자가 스텍에서 인수들을 정리합니다.<br>
            이름 수식 컨벤션  -> 함수명 앞에 @가 붙으며, 함수명 뒤에 인자 리스트의 바이트 크기를 @와 함께 표기한다.<br>
            ㅍ<p></p>
            fastcall 키워드는 ARM 및 x64 아키텍처를 타겟으로 하는 컴파일어에서는 허용되나 무시된다.<br>
            x64 칩의 컨벤션에 의해, 첫 4개의 인자는 가능하다면 레지스터에 전달되고, 추가적인 인자들은 스택에 전달됨<br>
            ARM 칩에서, 4개의 정수 인자와 8개의 부동소수점 인자는 레지스터에 전달될 것이며, 추가적인 인자는 스택에 전달됩니다.<br>
            비정적 클래스 함수의 경우, 함수의 정의가 클래스 블록 외부에서 정의된 경우, 선언시에만 호출 규약 지정자를 지정하고 함수를 정의하는 곳에서 별도로 함수 호출 규약을 지정할 필요가 없음/<br>
            <p></p>
            CPU 스케쥴링 -> CPU 스케쥴링이란  CPU를 잘 사용하기 위해 프로세스를 잘 배정 하는것이다.<br>
            CPU처리율과 CPU이용률이 증가 되며 오버해드. 응답시간, 반환 시간, 대기 시간, 기아 현상 이 닞아진다.<br>
            CPU스케쥴링의 종류는<br>
            선점 스케줄링, 비선점 스케쥴링 있다.<br>
            선점 스케쥴링은<br>
            하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식<br>
            비교적 응답이 빠르다는 장점이 있지만, 처리 시간을 예측하기 힘들고 높은 우선순위 프로세스들이 계속 들어오는 경우 오버헤드를 초래한다,<br>
            실시간 응답환경, Deadline 응답환경 등 우선순위가 높은 프로세스를 빠르게 처리해야 할 경우 등에 유용하다.<br>
            비선점형 스케줄링은<br>
            한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 PCU 점유가 불가능한 스케줄링 방식이다.<br>
            모든 프로세스에 대한 요구를 공정하게 처리할 수 있지만, 짧은 작업을 수행하는 프로세스가 긴 작업 종료 시까지 대기해야할 수도 있다,<br>
            처리시간 편차가 적은 특정 프로세스 환경에 용이하다.<br>
            <p></p>
            프로세스 상태 전이 과정은 다음과 같다<br>
            Dispatch (ready -> running)<br>
            여러 프로세스들 중 한 프로세스를 선정하여 CPU에 할당하는 과정이다<br>
            <p></p>
            Interrupt (running -> ready)<br>
            할당된 CPU 시간이 지나면 Timeout Interrupt 가 발생하여 CPU를 다른 프로세스에게 양도하고 자신은 ready 상태로 전이되는 과정<br>
            <p></p>
            Block (running -> waiting)<br>
            I/O 등의 자원 요청 후 즉시 할당받을 수 없어, 할당받을 때까지 기다리기 위해 running에서 waiting 상태로 전이되는 과정<br>
            I/O 처리는 CPU가 아닌 I/O 프로세스가 담당하기 때문에 block이 발생합니다<br>
            <p></p>
            Wakeup (waiting -> ready)<br>
            필요한 자원이 할당되면 프로세스는 waiting에서 ready 상태로 전이되는 과정이다<br>
            <p></p>
            socket 함수 -><br>
            $ 소켓이란 유닉스 파일 디스크립터(file descriptor)를 이용하여 다른 프로그램과 정보교환을 하는 방법(혹은 도구) 이다. 일반적으로 유닉스 상에서 정보교환은 파일 디스크립터를 통해 한다. 마찬가지로 소켓을 이용한 지역 혹은 네트워크로 연결된 프로그램 간의 정보교환 역시 파일 디스크립터를 통해서 이루어진다. <br>
            socket() 함수<br>
            소켓을 만드는데 바로 이 함수를 사용합니다. 소켓 역시 파일로 다루어지기 때문에 반환값은 파일디스크립터입니다. 만약 소켓을 여는데 실패했다면 -1을 리턴합니다.ㅍ<br>
            bind 함수 -><br>
            $ bind(int fd, struct sockaddr *local_addr, socklen_t addr_length)<br>
            소켓을 바인딩합니다. 이렇게 생각하면 됩니다. 지금 fd로 넘겨지는 소켓과 이 프로세스와 묶는다(bind)라고 생각하시면 됩니다. 그래서 해당 프로세스는 소켓을 통해 다른 컴퓨터로부터 연결을 받아들일 수 있습니다.<br>
            <p></p>
            listen 함수 -><br>
            $ listen(int fd, int backlog_queue_size)<br>
            소켓을 통해 들어오는 연결을 듣습니다. backlog_queue_size만큼 연결 요청을 큐에 넣습니다. 성공시 0, 오류시 -1을 반환합니다.<br>
            <p></p>
            accept 함수 -><br>
            $ accept(int fd, sockaddr *remote_host, socklen_t *addr_length)<br>
            어떤 컴퓨터에서 이 컴퓨터로 연결할때 연결을 받아들입니다.<br>
            연결된 원격 컴퓨터의 정보는 remote_host에 저장됩니다. 오류시에 -1을 반환합니다.<br>
            <p></p>
            connect함수 -> <br>
            $  connect(int fd, struct sockaddr *remote_host, socklen_t addr_length)<br>
            원격 호스트(원격 컴퓨터)와 연결하는 함수입니다. 연결된 정보는 remote_host에 저장됩니다. 성공시 0, 오류시 -1을 반환합니다.<br>
            <p></p>
            스트레스 테스트(부하 테스트) -><br>
            $ 부하 테스트란 임계깝 한계에 도달할 때 까지; 시스템 부하를 지속적으로 꾸준히 증가시켜 시스템을 테스트 하는 것<br>
            부하 테스트의 목적은<br>
            버퍼 오브플로우, 메모리 누수 및 잘못된 메모리 관리와 관련된 프로그램 결홤을 노출한다.<br>
            부하 테스팅의 결과로 발견되느 문제는 로드 벨렁신 문제, 대역폭 문제, 기존 시스템의 용량 등이 포함됨<br>
            데이터 베이스, 하드웨어, 네트워크 등의 응용 프로그램의 구성 요성의 상한을 결정함.<br>
            부하 테스트의 도구는 ,Jmeter, nGrine ,Gatling가 있다.<br>
            부하 테스트 진행 순서<br>
            주요 시나리오 테스트 // 주요 시나리오 선정 후 시나리오별로 얼마나 견디는지 테스트<br>
            트랜잭션별 단위 테스트 // 각 트랜잭션별로 얼마나 견디는지 테스트<br>
            주요 시나리오 가중치 테스트 //각 시나리오의 가중치를 부여하여 얼마나 견디는지 테스트<br>
            테스트 결과 공유 - >개선 후 다시 테스트 -> 결과 분석 이다.<br>
            <p></p>
            스트레스 테스트 도구  -><br>
            $ JMeter <br>
            apache 에서 자바로 만들어진 웹 어플리케이션 성능 테스트 오픈 소스다<br>
            JMeter에서는 <br>
            웹 HTTP. HTTPS(java, NodeJS, PHP, ASP, ENT ………)<br>
            Soap / rest 웹 서비스. FTP , JDBC, LDAP, JMS, Message-oriented middleware (MOM), Mail, SMTP(S), POP3(S) and IMAP(S) , Native commands or shell scripts<br>
            등을 지원한다.<br>
            <p></p>
            nGrinder<br>
            nGrinder는 네이버에서 제공하는 서버 부하 테스트 오픈 소스 프로젝트이다.<br>
            애플리케이션을 개발하고 nGrinder에서 여러가지 가상 시나리오를 만들어 트래픽에 몰렸을 때 성능을 측정할 수 있도록 도와준다<br>
            Controller //  사용자가 테스트 수행을 위한 스크립트를 생성하여 성능 측정을 위한 웹 인터페이스를 제공하며 테스트 결과를 수집해 통계를 보여준다.<br>
            Agent // Controller의 명령을 받아 작업을 수행하며 프로세스 및 스레드를 실행시켜 타겟이 되는 애플리케이션에 부하를 발생시킨다.<br>
            <p></p>
            Gatling <br>
            Gatling  웹 서버의 성능을 체크하는 오픈소스 프로젝트이다.<br>
            웹사이트나 rest API HTTP 기반 서버 성능ㅇ으 ㄹ테스트 하기 위해 사용되며 실제 서비스 환경과 유사하게 시뮬레이션 된다. <br>
            HTTP1.0과 1.1 -><br>
            $HTTP 1.0과 HTTP 1.1의 가장 큰 차이점은 연결 지속성이다 HTTP는 기본적으로 TCP를 이용하여 통신한다. HTTP 1.0은 세션을 유지하지 않고 HTTP 1.1은 세션을 유지한다<br>
            HTTP 1.0은 매번 데이터를 요청하고 수신할 때마다 새로운 TCP 세션을 맺어야 한다.<br>
            반면, HTTP 1.1은 한 번의 TCP 세션에 여러 개의 요청을 보내고 응답을 수신할 수 있다.<br>
            <p></p>
            즉, HTTP 1.0은 Non-persistent HTTP, HTTP 1.1은 Persistent HTTP라고 할 수 있다.<br>
            따라서 HTTP 1.1은 TCP 세션 처리 부하를 줄이고 응답속도를 개선 할 수 있다.<br>
            [그림 1]에서 확인 할 수 있듯이, 두 개의 요청과 응답을 처리하는 속도가 HTTP 1.1이 더 빠른 것을 확인할 수 있다.<br>
            TCP 세션을 열고 닫는 시간이 줄어들기 때문이다.<br>
            <p></p>
            HTTP 1.0은 파이프라이닝을 제공하지 않는다. 반면, HTTP 1.1은 파이프라이닝 기능을 제공한다.<br>
            즉, HTTP 1.0은 1번 요청을 보내고 1번 응답을 받아야지 2번 요청을 보내는 식으로 동작한다.<br>
            하지만 HTTP 1.1은 여러 개의 요청을 동시에 보낼 수 있다<br>
            <p></p>
            HTTP 1.0은 하나의 IP 주소에 여러 개의 도메인을 운영 할 수 없었다. 따라서 도메인 별로 IP를 구분해서 준비해야 하기 때문에 서버의 개수가 늘어나야 했다. 하지만 HTTP 1.1은 가상 호스팅(Virtual Hosting)이 가능해졌기 때문에 하나의 IP 주소에 여러 개의 도메인을 적용시킬 수 있다.  <br>  
        </body>
    </head>
</html> 